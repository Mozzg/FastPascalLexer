unit TestuPasLexer;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, System.SysUtils, System.Character, System.IOUtils, Winapi.Windows,
  uPasLexer, uPasLexerTypes, uPasParser;

type
  // Test methods for class TPasLexer

  TestTPasLexer = class(TTestCase)
  strict private
    FPasLexer: TPasLexer;
  public
    procedure SetUp; override;
    procedure TearDown; override;

    procedure AddLog(const AMessage: string);
  published
    procedure TestReset;
    procedure TestCounters1;
    procedure TestCounters2;
  end;

implementation

{ TestTPasLexer }

procedure TestTPasLexer.SetUp;
begin
  FPasLexer := TPasLexer.Create;
end;

procedure TestTPasLexer.TearDown;
begin
  FPasLexer.Free;
  FPasLexer := nil;
end;

procedure TestTPasLexer.AddLog(const AMessage: string);
begin
  if Assigned(FStatusStrings) then
  begin
    FStatusStrings.Clear;
  end;
  Status(AMessage);
end;

procedure TestTPasLexer.TestReset;
begin
  AddLog('Reset status');
  FPasLexer.Reset;

  CheckEquals(0, Length(FPasLexer.LexerState.IfDirectiveStateArray), 'IfDirectiveStateArray is not empty after reset');
  CheckEquals(0, Length(FPasLexer.LexerState.IfDirectiveSavedCountersArray), 'IfDirectiveSavedCountersArray is not empty after reset');
  CheckEquals(1, FPasLexer.LexerState.CurrentLine, 'CurrentLine is not 1 after reset');
  CheckTrue(FPasLexer.LexerState.CommentState = csNo, 'CommentState is not csNo after reset');
  CheckTrue(FPasLexer.LexerState.CurrentToken = tkUnknown, 'CurrentToken is not tkUnknown after reset');
  CheckTrue(FPasLexer.LexerState.LastSignificantToken = tkUnknown, 'LastSignificantToken is not tkUnknown after reset');
end;

procedure TestTPasLexer.TestCounters1;
var
  FileName, FileContent: string;
  WasInterface, WasImplementation: Boolean;
begin
  FileName := ExtractFilePath(ParamStr(0)) + '..\UnitTests\TestData\BeginEndCountTestUnit1.pas';
  FileName := ExpandFileName(FileName);
  AddLog('FileName=' + FileName);
  CheckTrue(FileExists(FileName), 'Test unit not found in FileExists');

  FileContent := TPasParser.GetFileDataString(FileName);
  FPasLexer.SetData(FileContent);

  WasInterface := False;
  WasImplementation := False;
  repeat
    FPasLexer.TokenString;
    case FPasLexer.TokenID of
      tkinterface:
      begin
        if not WasInterface then
        begin
          WasInterface := True;
          CheckEquals(0, FPasLexer.LexerState.Counters.RoundCount, 'RoundCount is not 0 at begining of Interface section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
          CheckEquals(0, FPasLexer.LexerState.Counters.SquareCount, 'SquareCount is not 0 at begining of Interface section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
          CheckEquals(0, FPasLexer.LexerState.Counters.IfDirectiveCount, 'IfDirectiveCount is not 0 at begining of Interface section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
        end;
      end;
      tkImplementation:
      begin
        if not WasImplementation then
        begin
          WasImplementation := True;
          CheckEquals(0, FPasLexer.LexerState.Counters.RoundCount, 'RoundCount is not 0 at begining of Implementation section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
          CheckEquals(0, FPasLexer.LexerState.Counters.SquareCount, 'SquareCount is not 0 at begining of Implementation section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
          CheckEquals(0, FPasLexer.LexerState.Counters.IfDirectiveCount, 'IfDirectiveCount is not 0 at begining of Implementation section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
        end;
      end;
    end;
  until not FPasLexer.NextToken;

  CheckTrue(WasInterface, 'Parser did not parse to Interface section');
  CheckTrue(WasImplementation, 'Parser did not parse to Implementation section');
  CheckEquals(0, FPasLexer.LexerState.Counters.RoundCount, 'RoundCount is not 0 at end of file');
  CheckEquals(0, FPasLexer.LexerState.Counters.SquareCount, 'SquareCount is not 0 at end of file');
  CheckEquals(0, FPasLexer.LexerState.Counters.IfDirectiveCount, 'IfDirectiveCount is not 0 at end of file');
end;

procedure TestTPasLexer.TestCounters2;
var
  FileName, FileContent: string;
  WasInterface, WasImplementation: Boolean;
begin
  FileName := ExtractFilePath(ParamStr(0)) + '..\UnitTests\TestData\BeginEndCountTestUnit2.pas';
  FileName := ExpandFileName(FileName);
  AddLog('FileName=' + FileName);
  CheckTrue(FileExists(FileName), 'Test unit not found in FileExists');

  FileContent := TPasParser.GetFileDataString(FileName);
  FPasLexer.SetData(FileContent);

  WasInterface := False;
  WasImplementation := False;
  repeat
    FPasLexer.TokenString;
    case FPasLexer.TokenID of
      tkinterface:
      begin
        if not WasInterface then
        begin
          WasInterface := True;
          CheckEquals(0, FPasLexer.LexerState.Counters.RoundCount, 'RoundCount is not 0 at begining of Interface section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
          CheckEquals(0, FPasLexer.LexerState.Counters.SquareCount, 'SquareCount is not 0 at begining of Interface section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
          CheckEquals(0, FPasLexer.LexerState.Counters.IfDirectiveCount, 'IfDirectiveCount is not 0 at begining of Interface section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
        end;
      end;
      tkImplementation:
      begin
        if not WasImplementation then
        begin
          WasImplementation := True;
          CheckEquals(0, FPasLexer.LexerState.Counters.RoundCount, 'RoundCount is not 0 at begining of Implementation section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
          CheckEquals(0, FPasLexer.LexerState.Counters.SquareCount, 'SquareCount is not 0 at begining of Implementation section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
          CheckEquals(0, FPasLexer.LexerState.Counters.IfDirectiveCount, 'IfDirectiveCount is not 0 at begining of Implementation section, '
              + 'Line=' + IntToStr(FPasLexer.LexerState.CurrentLine));
        end;
      end;
    end;
  until not FPasLexer.NextToken;

  CheckTrue(WasInterface, 'Parser did not parse to Interface section');
  CheckTrue(WasImplementation, 'Parser did not parse to Implementation section');
  CheckEquals(0, FPasLexer.LexerState.Counters.RoundCount, 'RoundCount is not 0 at end of file');
  CheckEquals(0, FPasLexer.LexerState.Counters.SquareCount, 'SquareCount is not 0 at end of file');
  CheckEquals(0, FPasLexer.LexerState.Counters.IfDirectiveCount, 'IfDirectiveCount is not 0 at end of file');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTPasLexer.Suite);
end.

